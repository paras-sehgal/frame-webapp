<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FRAME – Query</title>
<style>
  :root {
    --bg:#0f0f14; --panel:#141821; --text:#eaeaf2; --muted:#a8acc2;
    --accent:#8b5cf6; --accent2:#f59e0b; --ok:#10b981; --warn:#f59e0b; --err:#ef4444;
  }
  body{margin:0;background:var(--bg);color:var(--text);font:15px/1.35 ui-sans-serif,system-ui,-apple-system}
  .wrap{max-width:960px;margin:40px auto;padding:0 16px}
  .card{background:var(--panel);border-radius:14px;box-shadow:0 8px 30px rgba(0,0,0,.35);padding:18px;margin-bottom:18px}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  input,select,textarea,button{font:inherit}
  textarea, input, select{background:#0c0f15;color:var(--text);border:1px solid #242a38;border-radius:10px;padding:12px}
  textarea{width:100%;min-height:110px;resize:vertical}
  select{padding:10px 12px}
  .btn{background:var(--accent);border:none;color:white;border-radius:10px;padding:10px 14px;cursor:pointer}
  .btn.secondary{background:#263043}
  .btn.ghost{background:transparent;border:1px solid #384156}
  .btn:disabled{opacity:0.5;cursor:not-allowed}
  .pill{display:inline-block;background:#1d2230;border:1px solid #2a3042;color:var(--muted);padding:6px 10px;border-radius:999px;margin-right:6px;cursor:pointer}
  pre{background:#0b0e14;border:1px solid #1e2433;border-radius:10px;padding:12px;overflow:auto;white-space:pre-wrap}
  .hdr{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
  .logo{font-weight:800;letter-spacing:.25em;color:white}
  .status.ok{color:var(--ok)} .status.err{color:var(--err)} .status.warn{color:var(--warn)}
  .debug-info{background:#1a1d2e;border:1px solid #2a3042;border-radius:8px;padding:10px;margin-top:10px;font-size:13px;color:var(--muted)}
  .spinner{display:inline-block;width:12px;height:12px;border:2px solid #384156;border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite;margin-left:8px}
  @keyframes spin{to{transform:rotate(360deg)}}
</style>
</head>
<body>
<div class="wrap">
  <div class="card hdr">
    <div class="logo">F R A M E</div>
    <div>
      <span id="who" class="pill">signed-out</span>
      <button id="btnSignIn" class="btn">Sign in</button>
      <button id="btnSignOut" class="btn secondary" style="display:none">Sign out</button>
    </div>
  </div>

  <div class="card">
    <div class="row" style="align-items:center;gap:12px;margin-bottom:12px">
      <label>Dataset:&nbsp;
        <select id="dataset">
          <option value="movies">Movies</option>
          <option value="analytics">Analytics</option>
        </select>
      </label>
      <span id="envNote" class="pill">checking environment...</span>
    </div>

    <textarea id="nlq" placeholder="Ask a question (e.g., Top 10 movies worldwide since 2010)"></textarea>

    <div class="row" style="margin-top:10px">
      <button id="btnGen" class="btn">Generate SQL</button>
      <button id="btnRun" class="btn secondary">Run Query</button>
      <button id="btnSave" class="btn ghost">Save</button>
      <button id="btnCopySQL" class="btn ghost">Copy SQL</button>
      <button id="btnTest" class="btn ghost">Test Backend</button>
    </div>

    <div style="margin-top:10px">
      <span class="pill sug">Top 10 movies since 2010</span>
      <span class="pill sug">Average IMDb rating by genre (2015–2025)</span>
      <span class="pill sug">Directors with most Oscar wins since 1990</span>
    </div>
  </div>

  <div class="card">
    <div style="margin-bottom:6px;color:var(--muted)">Output</div>
    <input id="echo" style="width:100%" readonly />
    <div style="margin-top:8px;color:var(--muted)">SQL</div>
    <pre id="sqlPre"></pre>
    <div style="margin-top:8px;color:var(--muted)">Result</div>
    <pre id="resultPre"></pre>
    <div style="margin-top:8px">
      Worker: <span id="workerBeat" class="status warn">checking…</span>
      <span id="spinner" class="spinner" style="display:none"></span>
    </div>
    
    <div class="debug-info" id="debugInfo">
      <div>Firebase Status: <span id="firebaseStatus">initializing...</span></div>
      <div>Auth Status: <span id="authStatus">checking...</span></div>
      <div>Firestore Status: <span id="firestoreStatus">checking...</span></div>
      <div id="errorLog"></div>
    </div>
  </div>

  <div class="card" style="text-align:center;color:var(--muted)">
    FRAME · Query-first · Firebase Auth & Firestore · <span id="proj"></span>
  </div>
</div>

<!-- Firebase SDKs (modular v10) -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { 
    getAuth, 
    onAuthStateChanged, 
    signInWithPopup, 
    GoogleAuthProvider, 
    signOut
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
  import { 
    initializeFirestore,
    collection, 
    addDoc, 
    serverTimestamp, 
    onSnapshot, 
    query, 
    where, 
    orderBy, 
    limit,
    doc,
    getDocs,
    enableNetwork,
    disableNetwork
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  // Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyAaUpJhk-oopTDn_HnQvqQUMQxPHNlz3S8",
    authDomain: "frame-app-498.firebaseapp.com",
    projectId: "frame-app-498",
    storageBucket: "frame-app-498.firebasestorage.app",
    messagingSenderId: "252007542857",
    appId: "1:252007542857:web:b4ffa3e81e7f120b434f98",
    measurementId: "G-GWBXV2KBQM"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  
  // Initialize Firestore with forced long polling to bypass connection issues
  const db = initializeFirestore(app, {
    experimentalForceLongPolling: true,  // Forces HTTP long polling instead of WebSocket
    useFetchStreams: false  // Disables fetch streams
  });

  // Debug logging
  const logDebug = (message, type = 'info') => {
    console.log(`[FRAME] ${message}`);
    const errorLog = document.getElementById('errorLog');
    if (type === 'error' && errorLog) {
      errorLog.innerHTML = `<div style="color: var(--err)">${message}</div>`;
    }
  };

  document.getElementById('proj').textContent = firebaseConfig.projectId;
  document.getElementById('firebaseStatus').textContent = 'initialized ✓';
  
  // Test Firestore connection
  enableNetwork(db).then(() => {
    console.log('✅ Firestore network enabled');
    document.getElementById('firestoreStatus').textContent = 'connected ✓';
  }).catch(err => {
    console.error('⚠️ Firestore network warning:', err);
    document.getElementById('firestoreStatus').textContent = 'using fallback connection';
  });
  
  const $ = sel => document.querySelector(sel);
  
  function toast(msg) { 
    console.log('[FRAME]', msg);
    const toastEl = document.createElement('div');
    toastEl.style.cssText = 'position:fixed;top:20px;right:20px;background:var(--accent);color:white;padding:12px 20px;border-radius:8px;z-index:1000';
    toastEl.textContent = msg;
    document.body.appendChild(toastEl);
    setTimeout(() => toastEl.remove(), 3000);
  }

  // Simple NL → SQL generation
  function nl2sql(nlq, dataset) {
    nlq = (nlq || "").toLowerCase();
    if (dataset === 'movies') {
      if (nlq.includes('top 10') && nlq.includes('since 2010')) {
        return `SELECT title, worldwide_gross, release_year FROM movies WHERE release_year >= 2010 ORDER BY worldwide_gross DESC LIMIT 10;`;
      }
      if (nlq.includes('average') && nlq.includes('rating')) {
        return `SELECT genre, AVG(imdb_rating) as avg_rating FROM movies WHERE release_year BETWEEN 2015 AND 2025 GROUP BY genre ORDER BY avg_rating DESC;`;
      }
      if (nlq.includes('directors') && nlq.includes('oscar')) {
        return `SELECT director, COUNT(*) as oscar_wins FROM movies WHERE oscar_wins > 0 AND release_year >= 1990 GROUP BY director ORDER BY oscar_wins DESC LIMIT 10;`;
      }
    }
    return `SELECT * FROM ${dataset} LIMIT 50;`;
  }

  const who = $('#who');
  const btnSignIn = $('#btnSignIn');
  const btnSignOut = $('#btnSignOut');

  btnSignIn.onclick = async () => {
    try {
      const provider = new GoogleAuthProvider();
      const result = await signInWithPopup(auth, provider);
      toast('Signed in successfully!');
      document.getElementById('authStatus').textContent = `authenticated (${result.user.email})`;
    } catch(e) { 
      logDebug(`Sign-in error: ${e.message}`, 'error');
      alert('Sign-in error: ' + e.message); 
    }
  };

  btnSignOut.onclick = async () => {
    try {
      await signOut(auth);
      toast('Signed out');
    } catch(e) {
      logDebug(`Sign-out error: ${e.message}`, 'error');
    }
  };

  // Auth state observer
  onAuthStateChanged(auth, user => {
    if (user) {
      who.textContent = user.email;
      btnSignIn.style.display = 'none';
      btnSignOut.style.display = 'inline-block';
      document.getElementById('authStatus').textContent = `authenticated (${user.email})`;
      console.log('✅ Authenticated:', user.email, 'UID:', user.uid);
      listenForMyLatest(user.uid);
    } else {
      who.textContent = 'signed-out';
      btnSignIn.style.display = 'inline-block';
      btnSignOut.style.display = 'none';
      document.getElementById('authStatus').textContent = 'not authenticated';
    }
  });

  // Suggestion pills
  document.querySelectorAll('.sug').forEach(s => {
    s.addEventListener('click', () => {
      $('#nlq').value = s.textContent;
      toast('Query loaded');
    });
  });

  // Generate SQL button
  $('#btnGen').onclick = () => {
    const q = $('#nlq').value.trim();
    if (!q) {
      toast('Please enter a question first');
      return;
    }
    const ds = $('#dataset').value;
    const sql = nl2sql(q, ds);
    $('#echo').value = q;
    $('#sqlPre').textContent = sql;
    toast('SQL generated');
  };

  // Store active listeners to clean them up if needed
  let activeListeners = [];

  // Run Query button - NO TIMEOUT, let it run as long as needed
  $('#btnRun').onclick = async () => {
    const u = auth.currentUser;
    if (!u) { 
      alert('Please sign in first'); 
      return; 
    }
    
    const qtext = $('#nlq').value.trim();
    if (!qtext) { 
      alert('Please type a question first'); 
      return; 
    }
    
    // Disable button to prevent multiple submissions
    $('#btnRun').disabled = true;
    $('#spinner').style.display = 'inline-block';
    
    const ds = $('#dataset').value;
    const sessionId = `test-session-${Date.now()}`;
    
    try {
      logDebug('Sending query to backend...');
      toast('Sending query to model... This may take 1-2 minutes');
      
      // Create the document that the model expects
      const docRef = await addDoc(collection(db, 'queries'), {
        // Both field names in case backend expects either
        session_id: sessionId,
        model_session_id: sessionId,
        
        // The actual query
        input: qtext,
        
        // Required fields
        status: 'pending',
        createdAt: serverTimestamp(),
        processed_at: null,
        
        // User info
        user_id: u.uid,
        user_email: u.email,
        
        // Dataset info
        dataset: ds,
        
        // Fields that will be populated by backend
        output: '',
        raw_output: '',
        sql: '',
        error_message: '',
        result: null,
        rows: null
      });
      
      console.log('✅ Query document created:', docRef.id);
      console.log('Now waiting for backend to process... (this can take 1-2 minutes)');
      
      // Update UI
      $('#workerBeat').textContent = 'query sent, waiting for model...';
      $('#workerBeat').className = 'status warn';
      $('#resultPre').textContent = 'Processing query... This typically takes 1-2 minutes for complex queries.';
      
      // Listen for updates - NO TIMEOUT
      const unsubscribe = onSnapshot(doc(db, 'queries', docRef.id), (snapshot) => {
        if (snapshot.exists()) {
          const data = snapshot.data();
          console.log('Backend update:', data.status, data);
          
          // Update status indicator
          const badge = $('#workerBeat');
          
          if (data.status === 'completed' || data.status === 'done') {
            badge.textContent = 'completed ✓';
            badge.className = 'status ok';
            $('#spinner').style.display = 'none';
            $('#btnRun').disabled = false;
            
            // Display results - check all possible fields
            const output = data.output || data.raw_output || data.result || data.rows;
            if (output) {
              $('#resultPre').textContent = typeof output === 'string' ? output : JSON.stringify(output, null, 2);
              toast('Query completed!');
            } else {
              $('#resultPre').textContent = 'Query completed but no output received.';
            }
            
            // We can unsubscribe once complete
            unsubscribe();
            
          } else if (data.status === 'running' || data.status === 'processing') {
            badge.textContent = 'model is processing...';
            badge.className = 'status warn';
            $('#resultPre').textContent = 'Model is actively processing your query...';
            
          } else if (data.status === 'error' || data.status === 'failed') {
            badge.textContent = 'error';
            badge.className = 'status err';
            $('#spinner').style.display = 'none';
            $('#btnRun').disabled = false;
            $('#resultPre').textContent = `Error: ${data.error_message || data.error || 'Unknown error'}`;
            toast('Query failed - see error message');
            unsubscribe();
            
          } else {
            // Still pending or other status
            badge.textContent = data.status || 'waiting for backend...';
            badge.className = 'status warn';
          }
        }
      }, (error) => {
        console.error('Listener error:', error);
        $('#spinner').style.display = 'none';
        $('#btnRun').disabled = false;
        logDebug(`Listener error: ${error.message}`, 'error');
      });
      
      // Store listener reference
      activeListeners.push(unsubscribe);
      
      // NO TIMEOUT - let it run as long as needed
      // Dan said it can take 1-2 minutes, so we wait
      
    } catch(e) {
      console.error('Query failed:', e);
      logDebug(`Query failed: ${e.message}`, 'error');
      alert('Query failed: ' + e.message);
      $('#spinner').style.display = 'none';
      $('#btnRun').disabled = false;
      $('#workerBeat').textContent = 'error';
      $('#workerBeat').className = 'status err';
    }
  };

  // Save button (alias for Run)
  $('#btnSave').onclick = () => $('#btnRun').click();

  // Copy SQL button
  $('#btnCopySQL').onclick = async () => {
    const sqlText = $('#sqlPre').textContent;
    if (!sqlText) {
      toast('No SQL to copy');
      return;
    }
    try {
      await navigator.clipboard.writeText(sqlText);
      toast('SQL copied to clipboard');
    } catch(e) { 
      toast('Copy failed'); 
    }
  };

  // Test backend connection - also NO TIMEOUT
  $('#btnTest').onclick = async () => {
    const u = auth.currentUser;
    if (!u) { 
      alert('Please sign in first'); 
      return; 
    }
    
    try {
      toast('Sending test query to backend...');
      
      const testDoc = await addDoc(collection(db, 'queries'), {
        session_id: `test-${Date.now()}`,
        model_session_id: `test-${Date.now()}`,
        input: 'What is the highest grossing movie?',  // Simple test query
        status: 'pending',
        is_test: true,
        createdAt: serverTimestamp(),
        user_id: u.uid,
        user_email: u.email,
        dataset: 'movies'
      });
      
      console.log('Test document created:', testDoc.id);
      toast('Test sent: ' + testDoc.id + ' (waiting for backend...)');
      
      // Monitor response - NO TIMEOUT
      const unsubTest = onSnapshot(doc(db, 'queries', testDoc.id), (doc) => {
        const data = doc.data();
        if (data && data.status !== 'pending') {
          toast(`Backend responded: ${data.status}`);
          console.log('Backend test response:', data);
          if (data.status === 'completed' || data.status === 'done') {
            alert('✅ Backend is working!');
          } else if (data.status === 'error' || data.status === 'failed') {
            alert('⚠️ Backend responded with error: ' + (data.error_message || 'Unknown error'));
          }
          unsubTest();
        }
      });
      
      // NO TIMEOUT - let it wait for the backend
      
    } catch(e) {
      logDebug(`Test failed: ${e.message}`, 'error');
      alert('Test failed: ' + e.message);
    }
  };

  // Listen for latest query updates
  let unSubLatest = null;
  
  async function listenForMyLatest(uid) {
    if (unSubLatest) { 
      unSubLatest(); 
      unSubLatest = null; 
    }
    
    try {
      const q = query(
        collection(db, 'queries'),
        where('user_id', '==', uid),
        orderBy('createdAt', 'desc'),
        limit(1)
      );
      
      unSubLatest = onSnapshot(q, 
        snapshot => {
          snapshot.docChanges().forEach(change => {
            if (change.type === 'modified' || change.type === 'added') {
              const data = change.doc.data() || {};
              console.log('Latest query update:', data.status);
              
              // Update display with any output
              if (data.output || data.raw_output || data.result || data.rows) {
                const output = data.output || data.raw_output || data.result || data.rows;
                $('#resultPre').textContent = typeof output === 'string' ? output : JSON.stringify(output, null, 2);
              }
              
              // Update status badge
              const st = data.status || 'pending';
              const badge = $('#workerBeat');
              if (st === 'completed' || st === 'done') { 
                badge.textContent = 'completed'; 
                badge.className = 'status ok';
                $('#spinner').style.display = 'none';
              } else if (st === 'error' || st === 'failed') { 
                badge.textContent = 'error'; 
                badge.className = 'status err';
                $('#spinner').style.display = 'none';
              } else if (st === 'running' || st === 'processing') {
                badge.textContent = 'processing...'; 
                badge.className = 'status warn';
                $('#spinner').style.display = 'inline-block';
              } else { 
                badge.textContent = st; 
                badge.className = 'status warn'; 
              }
            }
          });
        },
        error => {
          console.error('Listener error:', error);
          logDebug(`Listener error: ${error.message}`, 'error');
        }
      );
    } catch(e) {
      logDebug(`Failed to set up listener: ${e.message}`, 'error');
    }
  }

  // Test Firestore connection on load
  setTimeout(async () => {
    try {
      const testQuery = query(collection(db, 'queries'), limit(1));
      const snapshot = await getDocs(testQuery);
      console.log('✅ Firestore test query successful! Found', snapshot.size, 'documents');
      document.getElementById('firestoreStatus').textContent = 'connected ✓';
    } catch (error) {
      console.error('⚠️ Firestore test query warning:', error);
      // Don't show as error since forced polling might still work
      document.getElementById('firestoreStatus').textContent = 'connected (fallback mode)';
    }
  }, 2000);

  // Check environment
  if (location.protocol === 'file:') {
    $('#envNote').textContent = '⚠️ Use http://localhost';
    $('#envNote').style.background = 'var(--err)';
  } else {
    $('#envNote').textContent = '✓ ' + location.origin;
    $('#envNote').style.background = 'var(--ok)';
    $('#envNote').style.color = 'white';
  }
</script>
</body>
</html>